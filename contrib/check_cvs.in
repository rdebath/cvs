#! @PERL@ -w
########################################################################
#
#  Copyright (c) 2000, 2001 by Donald Sharp <sharpd@cisco.com>
#  All Rights Reserved
#
#  Some portions Copyright (c) 2002, 2003 by
#                Derek R. Price <mailto:derek@ximbiot.com>
#                & Ximbiot <http://ximbiot.com>.
#  All rights reserved.
#
#  Permission is granted to copy and/or distribute this file, with or
#  without modifications, provided this notice is preserved.
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2, or (at your option)
#  any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.])
#
########################################################################

=head1 check_cvs.pl

    Script to check the integrity of the Repository

=head1 SYNOPSIS

    perldoc check_cvs.pl
    check_cvs.pl --help
    check_cvs.pl [--verbose!] [--cvsroot=CVSROOT] [--exec=SCRIPT]...
                 [module]...

=head1 DESCRIPTION

    This script will search through a repository and determine if
    any of the files in it are corrupted.

    Please do not run this script inside of the repository itself.
    This will cause it too fail.

=head1 OPTIONS

    --help           Print this very help text.
    -d,--cvsroot=CVSROOT
                     Use repository specified by CVSROOT.  Defaults to
                     the contents of the ./CVS/Root file when it exists
                     and is readable, then to the contents of the
                     $CVSROOT environment variable when it is set and
                     non-empty.
    -e,--exec=SCRIPT Execute (as from command prompt) or evaluate (as a
                     perl script) SCRIPT for each RCS archive in
                     CVSROOT.  Executed scripts are passed CVSROOT FILE
                     NAME, where CVSROOT is what you'd think, FILE is
                     the path to the file relative to CVSROOT and
                     suitable for use as an argument to cvs co, cvs
                     rlog, and so on, and NAME is FILE minus the path.
                     An evaluated SCRIPT will find the same three
                     arguments in the same order in @_.
    -v,--verbose     Print verbose debugging information.

=head1 ARGUMENTS

    modules   The module in the repository to examine.  Defaults to the
              contents of the ./CVS/Repository file when it exists and
              is readable, then to "." (all modules).

=head1 EXAMPLES

    setenv CVSROOT /release/111/cvs
    check_cvs.pl


    check_cvs.pl -d /another/cvsroot --verbose --exec '
    system "grep", "This string means I\'m a bad file!", "$_[2],v"
        or die "File $_[0]/$_[1],v is bad!"'

=head1 SEE ALSO

    None

=cut

######################################################################
#                    MODULES                                         #
######################################################################
use strict;

use Cwd;
use File::Find;
use File::Basename;
use File::Path;
use File::Spec;
use Getopt::Long;
use IO::File;
use Pod::Usage;

######################################################################
#                    GLOBALS                                         #
######################################################################

use vars qw(
            $cvsroot
            @extra_files
            @ignore_files
            @list_of_broken_files
            @scripts
            $total_revisions
            $total_interesting_revisions
            $total_files
            $verbose
           );



######################################################################
#                    SUBROUTINES                                     #
######################################################################

######################################################################
#
#    NAME :
#      main
#
#    PURPOSE :
#      To search the repository for broken files
#
#    PARAMETERS :
#      NONE
#
#    GLOBALS :
#      $cvsroot              - The CVS repository to search through.
#      $ENV{ CVSROOT }       - The default CVS repository to search through.
#      @list_of_broken_files - The list of files that need to
#                              be fixed.
#      $verbose              - is verbose mode on?
#      @scripts              - scripts to run on checked out files.
#      $total_revisions      - The number of revisions considered
#      $total_interesting_revisions - The number of revisions used
#      $total_files          - The total number of files looked at.
#
#    RETURNS :
#      A list of broken files
#
#    COMMENTS :
#      Do not run this script inside the repository.  Choose
#      a nice safe spot( like /tmp ) outside of the repository.
#
######################################################################
sub main
{
	my $help;

	$total_revisions = 0;
	$total_interesting_revisions = 0;
	$total_files = 0;

	Getopt::Long::Configure( "bundling" );
	unless( GetOptions( 'verbose|v!' => \$verbose,
	                    'cvsroot|d=s' => \$cvsroot,
	                    'help|h|?!' => \$help,
	                    'exec|e=s' => \@scripts ) )
	{
		pod2usage( 2 );
		exit 2;
	}

	pod2usage( -exitval => 2,
	           -verbose => 1,
	           -output => \*STDOUT )
		if $help;

	print STDERR "Verbose Mode Turned On\n" if $verbose;

	if( $verbose )
	{
		my $count;
		foreach my $script (@scripts)
		{
			$count++;
			print STDERR "Script $count: ***** ***** ***** ***** *****\n"
				. $script . "\n";
		}
	}

	if( !$cvsroot && -f "CVS/Root" && -r "CVS/Root" )
	{
		my $file = new IO::File "< CVS/Root";
		$cvsroot = $file->getline;
		chomp $cvsroot;
	}
	$cvsroot = $ENV{'CVSROOT'} unless $cvsroot;
	pod2usage( "error: Must set CVSROOT" ) unless $cvsroot;

	if( $cvsroot =~ /^:\w+:/ && $cvsroot !~ /^:local:/
	    || $cvsroot =~ /@/ )
	{
		print STDERR "CVSROOT must be :local:\n";
		exit 2;
	}

	for (@scripts)
	{
		$_ = File::Spec->rel2abs ($_) if -x $_;
	}


	if( !scalar( @ARGV ) && -f "CVS/Repository" && -r "CVS/Repository" )
	{
		my $file = new IO::File "< CVS/Repository";
		my $module = $file->getline;
		chomp $module;
		push @ARGV, $module;
	}

	push @ARGV, "." unless( scalar @ARGV );

	foreach my $directory_to_look_at ( @ARGV )
	{
		$directory_to_look_at = File::Spec->catfile( $cvsroot,
		                                             $directory_to_look_at );

		my $sym_count = 0;
		while( -l $directory_to_look_at )
		{
			$directory_to_look_at = readlink( $directory_to_look_at );
			$sym_count += 1;
			die( "Encountered too many symlinks for CVSROOT ($cvsroot)\n" )
				if( $sym_count > 5 );
		}

		print STDERR "Processing: $directory_to_look_at\n" if( $verbose );
		@ignore_files = get_ignore_files_from_cvsroot( $directory_to_look_at );
		find( \&process_file, $directory_to_look_at );

		my $num_files = @list_of_broken_files;
		print( "List of corrupted files\n" ) if( $num_files > 0 );
		foreach my $broken ( @list_of_broken_files )
		{
			print( "**** File: $broken\n" );
		}

		$num_files = @extra_files;
		print( "List of Files That Don't belong in Repository:\n" ) if( $num_files > 0 );
		foreach my $extra ( @extra_files )
		{
			print( "**** File: $extra\n" );
		}
		print( "Total Files: $total_files\n" );
		print( "Total Revisions: $total_revisions Interesting Revisions: $total_interesting_revisions\n" );
	}
}



######################################################################
#
#    NAME :
#      process_file
#
#    PURPOSE :
#      This function is called by the find function, it's purpose
#      is to decide if it is important to look at a file or not.
#      We only care about files that have the ,v at the end.
#
#    PARAMETERS :
#      NONE
#
#    GLOBALS :
#      $cvsroot               - The CVS repository to search through
#      $File::Find::name      - The absolute path of the file being examined.
#
#    RETURNS :
#      NONE
#
#    COMMENTS :
#      NONE
#
######################################################################
sub process_file
{
    my $path = $File::Find::name;

    $total_files += 1;
    $path =~ s#^$cvsroot/##;

    if( $path =~ /,v$/ )
    {
        $path =~ s/,v$//;
        look_at_cvs_file( $path );
    }
    elsif( ! -d $File::Find::name )
    {
        my $save = 0;
        foreach my $ignore ( @ignore_files )
        {
            if( $path =~ $ignore )
            {
                $save = 1;
                last;
            }
        }

        if( !$save )
        {
            push( @extra_files, $path );
        }
    }
}

######################################################################
#
#    NAME :
#      look_at_cvs_file
#
#    PURPOSE :
#      To decide if a file is broken or not.  The algorithm is:
#      a)  Get the revision history for the file.
#              - If that fails the file is broken, save the fact
#                and continue processing other files.
#              - If that succeeds we have a list of revisions.
#      b)  For Each revision try to retrieve that version
#              - If that fails the file is broken, save the fact
#                and continue processing other files.
#      c)  Attempt to exec or evaluate any scripts in @scripts (passed in as
#          arguments to --exec).  If executable scripts exit with a non-zero
#          status or evaluated scripts set $@ (die), print $status or $@
#          as a warning.
#      d)  Continue on 
#
#    PARAMETERS :
#      $file - The path of the file to look at, relative to $cvsroot and
#              suitable for use as an argument to `cvs co', `cvs rlog', and
#              the rest of CVS's r* commands.
#
#    GLOBALS :
#      NONE
#
#    RETURNS :
#      NONE
#
#    COMMENTS :
#      We have to handle Attic files in a special manner.
#      Basically remove the Attic from the string if it
#      exists at the end of the $path variable.
#
######################################################################
sub look_at_cvs_file
{
    my( $file ) = @_;
    my( $name, $path ) = fileparse( $file );

    if( $path =~ s#Attic/$## )
    {
        $file = $path . $name;
    }

    my $revisions = get_history( $name );

    if( !defined( $revisions ) )
    {
        print "\t$file is corrupted, this was determined via a cvs log command"
		      . "\n"
			if $verbose;
        push( @list_of_broken_files, $file );
        return();
    }

    my @int_revisions = find_interesting_revisions( @$revisions );

    foreach my $revision ( @int_revisions )
    {
        print "\t\tLooking at Revision: $revision\n" if $verbose;
        if( !check_revision( $file, $revision ) )
        {
            print "\t$file is corrupted in revision: $revision\n"
				if $verbose;
            push( @list_of_broken_files, $file );
            return();
        }
    }

	my $count;
	foreach my $script (@scripts)
	{
		$count++;
		if (-x $script)
		{
			# exec external script
			my $status = system $script, $cvsroot, $file, $name;
			warn "'$script $cvsroot $file $name' exited with status " . $status
				if $status;
		}
		else
		{
			# eval script
			@_ = ($cvsroot, $file, $name);
			eval $script;
			warn "script $count ($cvsroot, $file, $name) exited abnormally: "
			     . $@
				if $@;
		}
	}
}

######################################################################
#
#    NAME :
#      get_history
#
#    PURPOSE :
#      To retrieve a array of revision numbers.
#
#    PARAMETERS :
#      $file - The file to retrieve the revision numbers for
#
#    GLOBALS :
#      NONE
#
#    RETURNS :
#      On Success - Reference to the list of revision numbers
#      On Failure - undef.
#
#    COMMENTS :
#      The $_ is saved off because The File::find functionality
#      expects the $_ to not have been changed.
#      The -N option for the rlog command means to spit out 
#      tags or branch names.
#
######################################################################
sub get_history
{
	my( $file ) = @_;
	$file =~ s/(["\$`\\])/\\$1/g;
	my @revisions;
	my $revision;

	my $fh = new IO::File( "rlog -N \"$file\" 2>&1 |" )
		or die( "unable to run rlog, help" );

	my $ignore = 1;
    while( my $line = $fh->getline )
    {
		# rlog outputs a "----" line before the actual revision
		# without this we'll pick up peoples comments if they 
		# happen to start with revision
		if( $line =~ /^----------------------------$/ )
		{
			$ignore = 0;
			next;
		}

		if( ( !$ignore ) && ( ( $revision ) = $line =~ m/^revision (\S+)/ ) )
		{
			push( @revisions, $revision );
			$ignore = 1;
        }
    }

    if( !$fh->close )
    {
        return( undef );
    }

    return( \@revisions );
}

######################################################################
#
#    NAME :
#      check_revision
#
#    PURPOSE :
#      Given a file and a revision number ensure that we can 
#      check out that file
#
#    PARAMETERS :
#      $file     - The file to look at.
#      $revision - The revision to look at.
#
#    GLOBALS :
#      NONE
#
#    RETURNS :
#      If we can get the File - 1
#      If we can not get the File - 0
#
#    COMMENTS :
#      cvs command line options are as followed:
#        -l - Do not log this command in the history file.  I am
#             doing this because we will literaly be looking at 
#             thousands of files with *lots* of revisions.
#        -n - Do not run any checkout program as specified by the -o
#             option in the modules file
#        -p - Put all output to standard out.
#        -r - The revision of the file that we would like to look at.
#      Please note that cvs will return 0 for being able to successfully
#      read the file and 1 for failure to read the file.
#
######################################################################
sub check_revision
{
    my( $file, $revision ) = @_;
	$file =~ s/(["\$`\\])/\\$1/g;

    my $cwd = getcwd();
    chdir( "/tmp" );

    my $ret_code = 0xffff & system( "cvs -d $cvsroot -l co -n -p -r $revision \"$file\" > /dev/null 2>&1" );

    chdir( $cwd );
    return( 1 ) if ( $ret_code == 0 );
    return( 0 );

    return( $ret_code );
}

######################################################################
#
#    NAME :
#      find_interesting_revisions
#
#    PURPOSE :
#      CVS stores information in a logical manner.  We only really
#      need to look at some interestin revisions.  These are:
#      The first version
#      And the last version on every branch.
#      This is because cvs stores changes descending from 
#      main line. ie suppose the last version on mainline is 1.6
#      version 1.6 of the file is stored in toto.  version 1.5
#      is stored as a diff between 1.5 and 1.6.  1.4 is stored 
#      as a diff between 1.5 and 1.4.
#      branches are stored a little differently.  They are 
#      stored in ascending order.  Suppose there is a branch
#      on 1.4 of the file.  The first branches revision number
#      would be 1.4.1.1.  This is stored as a diff between 
#      version 1.4 and 1.4.1.1.  The 1.4.1.2 version is stored
#      as a diff between 1.4.1.1 and 1.4.1.2.  Therefore
#      we are only interested in the earliest revision number
#      and the highest revision number on a branch.
#
#    PARAMETERS :
#      @revisions - The list of revisions to find interesting ones
#
#    GLOBALS :
#      NONE
#
#    RETURNS :
#      @new_revisions - The list of revisions that we find interesting
#
#    COMMENTS :
#
######################################################################
sub find_interesting_revisions
{
    my( @revisions ) = @_;
    my @new_revisions;
    my %branch_revision;
    my $branch_number;
    my $branch_rev;
    my $key;
    my $value;

    START_OVER:
    foreach my $revision( @revisions )
    {
        my $start_over = 0;
        ( $branch_number, $branch_rev ) = branch_split( $revision );

        #if the number of elements in the branch is 1
        #and the new branch is less than the old branch
        if( elements_in_branch( $branch_number ) == 1 )
        {
            ( $start_over,
              %branch_revision ) = find_int_mainline_revision( $branch_number,
                                                               $branch_rev,
                                                               %branch_revision );
            next START_OVER if( $start_over );
        }

        %branch_revision = find_int_branch_revision( $branch_number,
                                                     $branch_rev,
                                                     %branch_revision );

    }

    %branch_revision = remove_duplicate_branches( %branch_revision );

    while( ( $key, $value ) = each ( %branch_revision ) )
    {
        push( @new_revisions, $key . "." . $value );
    }

    my $nrc;
    my $rc;

    $rc = @revisions;
    $nrc = @new_revisions;

    $total_revisions += $rc;
    $total_interesting_revisions += $nrc;

    print( "\t\tTotal Revisions: $rc Interesting Revisions: $nrc\n" ) if( $verbose );

    return( @new_revisions );
}

########################################################################
#
#    NAME :
#      remove_duplicate_branches
#
#    PURPOSE :
#      To remove from the list of branches that we are interested
#      in duplication that will cause cvs to check a revision multiple
#      times.  For Instance revision 1.1.1.1 should be prefered
#      to be checked over revision 1.1, as that v1.1.1.1 can
#      only be retrieved by going through v1.1.  Therefore
#      we should remove v1.1 from the list of branches that
#      are interesting.
#
#    PARAMETERS :
#      %branch_revisions - The hash of the interesting revisions
#
#    GLOBALS :
#      NONE
#
#    RETURNS :
#      %branch_revisions - The hash of the modified interesting revisions
#
#    COMMENTS :
#      NONE
#
########################################################################
sub remove_duplicate_branches
{
    my( %branch_revisions ) = @_;
    my $key;
    my $value;
    my $branch_comp;
    my $branch;


  RESTART:
    {
        my @keys = keys( %branch_revisions );
        while( ( $key, $value ) = each ( %branch_revisions ) )
        {
            $branch_comp = $key . "." . $value;
            foreach $branch ( @keys )
            {
                if( $branch eq $key )
                {
                    next;
                }
                if( elements_in_branch( $branch_comp ) ==
                    elements_in_branch( $branch ) - 1 )
                {
                    if( $branch =~ /^$branch_comp/ )
                    {
                        delete( $branch_revisions{ $key } );
                        goto RESTART;
                    }
                }
            }
        }
    }

    return( %branch_revisions );
}

######################################################################
#
#    NAME :
#      find_int_branch_revision
#
#    PURPOSE :
#      To Find a interesting branch revision.
#      Algorithm:
#        If the $branch_revision exists in the interesting branch
#        hash and the new $branch_rev is less than currently saved
#        one replace it with the new $branch_rev.
#        else if the $branch_revision doesn't exist in the interesting
#        branch hash, then just store the $branch_number and $branch_rev
#
#    PARAMETERS :
#      $branch_number - The branch that we are looking at
#      $branch_rev    - The particular revision we are looking
#                       at on the $branch_number.
#      %branch_revision - The hash storing the interesting branches
#                         and the revisions on them.
#
#    GLOBALS :
#      NONE
#
#    RETURNS :
#      %branch_revision - The modified hash that stores interesting
#                         branches.
#
#    COMMENTS :
#      NONE
#
######################################################################
sub find_int_branch_revision
{
    my( $branch_number, $branch_rev, %branch_revision ) = @_;

    if( exists( $branch_revision{ $branch_number } ) )
    {
        if( $branch_rev > $branch_revision{ $branch_number } )
        {
            $branch_revision{ $branch_number } = $branch_rev;
        }
    }
    else
    {
        $branch_revision{ $branch_number } = $branch_rev;
    }

    return( %branch_revision );
}

######################################################################
#
#    NAME :
#      find_int_mainline_revision
#
#    PURPOSE :
#      To Find a interesting mainline revision.
#      Algorithm:
#        if the $branch_number is less then a branch number
#        with one element in it, then delete the old branch_number
#        and return.
#        if the $branch_number is greater than a branch number
#        then return, and tell the calling function that we
#        should skip this element, as that it's not important.
#        if the $branch_number is the same as a branch number
#        with one element in it, then check to see if the
#        $branch_rev is less than the stored branch rev if
#        it is replace with new $branch_rev.  Else ignore revision
#
#    PARAMETERS :
#      $branch_number - The branch that we are looking at
#      $branch_rev    - The particular revision we are looking
#                       at on the $branch_number.
#      %branch_revision - The hash storing the interesting branches
#                         and the revisions on them.
#
#    GLOBALS :
#      NONE
#
#    RETURNS :
#      ( $skip, %branch_revision ) -
#      $skip - 1 if we need to ignore this particular $branch_number
#              $branch_rev combo.  Else 0.
#      %branch_revision - The modified hash that stores interesting
#                         branches.
#
#    COMMENTS :
#      NONE
#
######################################################################
sub find_int_mainline_revision
{
    my( $branch_number, $branch_rev, %branch_revision ) = @_;

    foreach my $key ( keys %branch_revision )
    {
        if( elements_in_branch( $key ) == 1 )
        {
            if( $branch_number < $key )
            {
                delete( $branch_revision{ $key } );
                next;
            }

            if( $branch_number > $key )
            {
                return( 1, %branch_revision );
            }
            if( ( exists( $branch_revision{ $branch_number } ) ) &&
                ( $branch_rev < $branch_revision{ $branch_number } ) )
            {
                $branch_revision{ $branch_number } = $branch_rev;
                return( 1, %branch_revision );
            }
        }
    }

    return( 0, %branch_revision );
}

######################################################################
#
#    NAME :
#      elements_in_branch
#
#    PURPOSE :
#      Determine the number of elements in a revision number
#      Elements are defined by numbers seperated by ".".
#      the revision 1.2.3.4 would have 4 elements
#      the revision 1.2.4.5.6.7 would have 6 elements
#
#    PARAMETERS :
#      $branch - The revision to look at.
#
#    GLOBALS :
#      NONE
#
#    RETURNS :
#      $count - The number of elements
#
#    COMMENTS :
#      NONE
#
######################################################################
sub elements_in_branch
{
    my( $branch ) = @_;
    my @split_rev;

    @split_rev = split /\./, $branch;

    my $count = @split_rev;
    return( $count );
}

######################################################################
#
#    NAME :
#      branch_split
#
#    PURPOSE :
#      To split up a revision number up into the branch part and
#      the number part.  For Instance:
#      1.1.1.1 - is split 1.1.1 and 1
#      2.1     - is split 2 and 1
#      1.3.4.5.7.8 - is split 1.3.4.5.7 and 8
#
#    PARAMETERS :
#      $revision - The revision to look at.
#
#    GLOBALS :
#      NONE
#
#    RETURNS :
#      ( $branch, $revision ) - 
#      $branch - The branch part of the revision number 
#      $revision - The revision part of the revision number
#
#    COMMENTS :
#      NONE
#
######################################################################
sub branch_split
{
    my( $revision ) = @_;
    my $branch;
    my $version;
    my @split_rev;
    my $count;

    @split_rev = split /\./, $revision;

    my $numbers = @split_rev;     
    @split_rev = reverse( @split_rev );
    $branch = pop( @split_rev );
    for( $count = 0; $count < $numbers - 2 ; $count++ )
    {
        $branch .= "." . pop( @split_rev );
    }

    return( $branch, pop( @split_rev ) );
}

######################################################################
#
#    NAME :
#      get_ignore_files_from_cvsroot
#
#    PURPOSE :
#      Retrieve the list of files from the CVSROOT/ directory
#      that should be ignored. 
#      These are the regular files (e.g., commitinfo, loginfo)
#      and those specified in the checkoutlist file.
#
#    PARAMETERS :
#      The CVSROOT
#
#    GLOBALS :
#      NONE
#
#    RETURNS :
#      @ignore - the list of files to ignore
#
#    COMMENTS :
#      NONE
#
######################################################################
sub get_ignore_files_from_cvsroot {
    my( $cvsroot ) = @_;
    my @ignore = (
	               qr{CVS/fileattr$}o,
                   qr{^(./)?CVSROOT/.#[^/]*$}o,
                   qr{^(./)?CVSROOT/loginfo$}o,
                   qr{^(./)?CVSROOT/rcsinfo$}o,
                   qr{^(./)?CVSROOT/editinfo$}o,
                   qr{^(./)?CVSROOT/verifymsg$}o,
                   qr{^(./)?CVSROOT/commitinfo$}o,
                   qr{^(./)?CVSROOT/taginfo$}o,
                   qr{^(./)?CVSROOT/cvsignore$}o,
                   qr{^(./)?CVSROOT/checkoutlist$}o,
                   qr{^(./)?CVSROOT/cvswrappers$}o,
                   qr{^(./)?CVSROOT/notify$}o,
                   qr{^(./)?CVSROOT/modules$}o,
                   qr{^(./)?CVSROOT/readers$}o,
                   qr{^(./)?CVSROOT/writers$}o,
                   qr{^(./)?CVSROOT/passwd$}o,
                   qr{^(./)?CVSROOT/config$}o,
                   qr{^(./)?CVSROOT/val-tags$}o,
                   qr{^(./)?CVSROOT/history$}o
	             );

    my $checkoutlist_file = "$cvsroot/CVSROOT/checkoutlist";
	if( -f $checkoutlist_file && -r $checkoutlist_file )
	{
		my $fh = new IO::File "<$checkoutlist_file"
			or die "Unable to read checkoutlist file ($checkoutlist_file): $!\n";

		my @list = $fh->getlines;
		chomp( @list );
		$fh->close or die( "Unable to close checkoutlist file: $!\n" );

		foreach my $line( @list )
		{
			next if( $line =~ /^#/ || $line =~ /^\s*$/ );
			$line =~ s/^\s*(\S*)\s*$/$1/;
			push @ignore, qr{^(./)?CVSROOT/$line$};
		}
	}	

    return @ignore;
}



######
###### Go.
######

exit main @ARGV;

# vim:tabstop=4:shiftwidth=4
