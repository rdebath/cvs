*** client.c.~1~	Thu Aug 10 17:53:32 1995
--- client.c	Sat Aug 12 15:23:58 1995
***************
*** 582,588 ****
  		    strcpy (dir, dirname);
  		  }
  
! 		if (CVS_MKDIR (dir, 0777) < 0)
  		{
  		    if (errno != EEXIST)
  			error (1, errno, "cannot make directory %s", dir);
--- 582,588 ----
  		    strcpy (dir, dirname);
  		  }
  
! 		if (mkdir (dir, 0777) < 0)
  		{
  		    if (errno != EEXIST)
  			error (1, errno, "cannot make directory %s", dir);
***************
*** 710,716 ****
  
  	buf[0] = *s++;
  	buf[1] = *s++;
! 	stored_checksum[i] = (char) strtol (buf, &bufend, 16);
  	if (bufend != buf + 2)
  	    break;
      }
--- 710,716 ----
  
  	buf[0] = *s++;
  	buf[1] = *s++;
! 	stored_checksum[i] = strtol (buf, &bufend, 16);
  	if (bufend != buf + 2)
  	    break;
      }
***************
*** 2301,2382 ****
       int *tofdp;
       int *fromfdp;
  {
!     int to_server_pipe[2];
!     int from_server_pipe[2];
  
!     if (pipe (to_server_pipe) < 0)
! 	error (1, errno, "cannot create pipe");
!     if (pipe (from_server_pipe) < 0)
! 	error (1, errno, "cannot create pipe");
! 
!     rsh_pid = fork ();
!     if (rsh_pid < 0)
! 	error (1, errno, "cannot fork");
!     if (rsh_pid == 0)
!     {
! 	if (dup2 (to_server_pipe[0], STDIN_FILENO) < 0)
! 	    error (1, errno, "cannot dup2");
! 	if (close (to_server_pipe[1]) < 0)
! 	    error (1, errno, "cannot close");
! 	if (close (from_server_pipe[0]) < 0)
! 	    error (1, errno, "cannot close");
! 	if (dup2 (from_server_pipe[1], STDOUT_FILENO) < 0)
! 	    error (1, errno, "cannot dup2");
! 
! 	{
! 	  /* If you're working through firewalls, you can set the
! 	     CVS_RSH environment variable to rsh and rsh invocation on
! 	     a proxy machine.  */
! 	  char *cvs_rsh = getenv ("CVS_RSH");
! 	  char *cvs_server = getenv ("CVS_SERVER");
! 	  char *command;
! 
! 	  if (!cvs_rsh)
! 	    cvs_rsh = "rsh";
! 	  if (!cvs_server)
! 	    cvs_server = "cvs";
! 
! 	  /* Pass the command to rsh as a single string.  This
! 	     shouldn't affect most rsh servers at all, and will pacify
! 	     some buggy versions of rsh that grab switches out of the
! 	     middle of the command (they're calling the GNU getopt
! 	     routines incorrectly).  */
! 	  command = xmalloc (strlen (cvs_server)
! 			     + strlen (server_cvsroot)
! 			     + 50);
! 
! 	  /*
! 	   * The -d here is really cheesy, because it is redundant
! 	   * with the Root request, inconsistent with how we do things
! 	   * when we aren't using rsh, and the code in main.c which
! 	   * prints an error on a bad root just writes to stderr
! 	   * rather than using the protocol.
! 	   * 
! 	   * But I'm leaving it in for now because old (Nov 3, 1994)
! 	   * versions of the server say "`cvs server' is for internal
! 	   * use--don't use it directly" if you try to start them up
! 	   * without -d and your .bashrc sets CVSROOT to something
! 	   * containing a colon.  */
! 	  sprintf (command, "%s -d %s server", cvs_server, server_cvsroot);
! 
!           /* If the login names differ between client and server
!            *  pass it on to rsh
!            */
!           if(server_user != NULL) {
!             execlp (cvs_rsh, cvs_rsh, server_host, 
!                     "-l", server_user, command, (char *) NULL);
!           } else {
!             execlp (cvs_rsh, cvs_rsh, server_host, command, (char *)NULL);
!           }			
  	}
! 	error (1, errno, "cannot exec");
!       }
!     if (close (to_server_pipe[0]) < 0)
!       error (1, errno, "cannot close");
!     if (close (from_server_pipe[1]) < 0)
!       error (1, errno, "cannot close");
!     *tofdp = to_server_pipe[1];
!     *fromfdp = from_server_pipe[0];
  }
  
  
--- 2301,2364 ----
       int *tofdp;
       int *fromfdp;
  {
!     /* If you're working through firewalls, you can set the
!        CVS_RSH environment variable to rsh and rsh invocation on
!        a proxy machine.  */
!     char *cvs_rsh = getenv ("CVS_RSH");
!     char *cvs_server = getenv ("CVS_SERVER");
!     char *command;
! 
!     if (!cvs_rsh)
! 	cvs_rsh = "rsh";
!     if (!cvs_server)
! 	cvs_server = "cvs";
! 
!     /* Pass the command to rsh as a single string.  This shouldn't
!        affect most rsh servers at all, and will pacify some buggy
!        versions of rsh that grab switches out of the middle of the
!        command (they're calling the GNU getopt routines incorrectly).  */
!     command = xmalloc (strlen (cvs_server)
! 		       + strlen (server_cvsroot)
! 		       + 50);
  
!     /*
!      * The -d here is really cheesy, because it is redundant
!      * with the Root request, inconsistent with how we do things
!      * when we aren't using rsh, and the code in main.c which
!      * prints an error on a bad root just writes to stderr
!      * rather than using the protocol.
!      * 
!      * But I'm leaving it in for now because old (Nov 3, 1994)
!      * versions of the server say "`cvs server' is for internal
!      * use--don't use it directly" if you try to start them up
!      * without -d and your .bashrc sets CVSROOT to something
!      * containing a colon.  */
!     sprintf (command, "%s -d %s server", cvs_server, server_cvsroot);
! 
!     {
!         char *argv[10];
! 	char **p = argv;
! 
! 	*p++ = cvs_rsh;
! 	*p++ = server_host;
! 
! 	/* If the login names differ between client and server
! 	 * pass it on to rsh.
! 	 */
! 	if (server_user != NULL)
! 	{
! 	    *p++ = "-l";
! 	    *p++ = server_user;
  	}
! 
! 	*p++ = command;
! 	*p++ = NULL;
! 
! 	rsh_pid = piped_child (argv, tofdp, fromfdp);
! 
! 	if (rsh_pid < 0)
! 	    error (1, errno, "cannot start server via rsh");
!     }
  }
  
  
